@page "/"

@using Engine;
@using Microsoft.AspNetCore.SignalR.Client;
@using dfe.Client.Engine.Network;
@using dfe.Shared.Entities;
@using dfe.Shared.Render;
@using System.Numerics;
@using System.Collections; 

@inject IJSRuntime JsRuntime;
@inject NavigationManager NavigationManager;


<div id="game_view_container">
    <div>
        <canvas tabindex="0" id="game_canvas" width="640" height="480"
                @ref="render_canvas"
                @onkeydown="handleKeyDown"
                @onkeyup="handleKeyUp"
                @onpointerdown="handlePointerDown"
                @onmousemove="handleMouse">
        </canvas>
    </div>
    <div hidden="@game_started">
        <div class="centered" style="width: 100%; height: 100%; background-color: gray; opacity: 0.5;">
        </div>
        <div class="centered">
            <button @onclick="showGame">Start Game</button>
        </div>
    </div>
</div>

<div id="chat_container">

    <hr />

    <div>
        <label>
            User:
            <input @bind="user_input" />
        </label>
    </div>
    <div>
        <label>
            Message:
            <input @bind="msg_input" size="50" />
        </label>
    </div>
    <button @onclick="sendMsg" disabled="@(!isConnected)">Send</button>

    <hr />

    <ul>
        @foreach (var message in messages)
        {
            <li>@message</li>
        }
    </ul>
</div>

<div id="audio-elements">
    <input type="checkbox" @onchange="muteClicked" checked /> <label>Mute</label>
    @* For organization purposes, this will contain the audio elements until we have a better audio system in place. *@
</div>

@code {

    // TODO: Need to store a cookie on client machine to save options state (mute, etc,)

    //GameClient game_client = new GameClient();

    protected ElementReference render_canvas;

    private bool b_is_audio_muted = true;

    private Guid local_player_guid;

    private Tracer ray_tracer;
    private ChatClient chat_client;
    private MapClient map_client;

    private Dictionary<Guid, Player> connected_players = new Dictionary<Guid, Player>();

    // network
    private HubConnection chat_hub_conn;
    private HubConnection map_hub_conn;
    private HubConnection player_hub_conn;

    private List<string> messages = new List<string>();
    private string user_input;
    private string msg_input;

    private bool game_started = false;

    protected override async Task OnInitializedAsync()
    {
        ray_tracer = new Tracer();


        player_hub_conn = new HubConnectionBuilder().WithUrl(NavigationManager.ToAbsoluteUri("/playerhub")).Build();
        player_hub_conn.StartAsync();

        map_hub_conn = new HubConnectionBuilder().WithUrl(NavigationManager.ToAbsoluteUri("/maphub")).Build();

        chat_hub_conn = new HubConnectionBuilder().WithUrl(NavigationManager.ToAbsoluteUri("/chathub")).Build();

        // TODO: Move player hub connection code to separate class
        // TODO: Differentiate between local and non-local players
        player_hub_conn.On<bool, Guid>("receiveRegistrationResponse", (b_is_registered, player_guid) =>
        {
            local_player_guid = player_guid;
            if (b_is_registered)
            {

                // TODO: instantiate map and chat clients earlier but don't start gameloop until registration is complete
                // TODO: also, we should probably keep map and chat hidden until we successfully register with server

                map_client = new MapClient(map_hub_conn);
                map_client.ray_tracer = ray_tracer;

                map_client.loadMapFromServer();

                chat_client = new ChatClient(chat_hub_conn);
                chat_client.onChatUpdated += refreshMessages;

            }
            else
            {
                Console.WriteLine("Client registration failed.");
            }


        });

        player_hub_conn.On<Player[]>("updateConnectedPlayers", (player_connections) =>
        {
            Console.WriteLine("Updating connected players: {0}", player_connections.Length);
            foreach (Player plyr in player_connections)
            {
                if (plyr.guid != local_player_guid)
                {
                    if (connected_players.ContainsKey(plyr.guid))
                    {
                        connected_players[plyr.guid].coord = plyr.coord;
                        connected_players[plyr.guid].position.X = plyr.coord.X;
                        connected_players[plyr.guid].position.Y = plyr.coord.Y;
                        connected_players[plyr.guid].sprite = map_client.level_map.sprites[1].pb_data;
                    }
                    else
                    {
                        Player temp_player = new Player(plyr.coord.X, plyr.coord.Y, 0.0f);
                        temp_player.sprite = new PixelBuffer(16, 16);
                        temp_player.sprite = map_client.level_map.sprites[1].pb_data;
                        temp_player.guid = plyr.guid;
                        connected_players.Add(temp_player.guid, temp_player);
                    }
                    Console.WriteLine("Player {0} X: {1} Y: {2}", plyr.guid, plyr.coord.X, plyr.coord.Y);
                }
            }
        });

        player_hub_conn.On<Dictionary<Guid, Coord>>("updatePlayerPositions", (player_positions) =>
        {
            foreach (KeyValuePair<Guid, Coord> player_conn in player_positions)
            {
                Guid plyr_id = player_conn.Key;
                Coord position = player_conn.Value;
                if (connected_players.ContainsKey(plyr_id))
                {
                    connected_players[plyr_id].coord = position;
                    connected_players[plyr_id].position.X = position.X;
                    connected_players[plyr_id].position.Y = position.Y;
                }
            }
        });

        await player_hub_conn.SendAsync("registerPlayerConnection", "TestPlayer", ray_tracer.self);

        await base.OnInitializedAsync();
    }

    protected override async Task OnAfterRenderAsync(bool first_render)
    {
        if (first_render)
        {
            await JsRuntime.InvokeAsync<object>("initGame", DotNetObjectReference.Create(this));
        }

    }

    private async void muteClicked(ChangeEventArgs event_args)
    {
        b_is_audio_muted = bool.Parse(event_args.Value.ToString());
        await JsRuntime.InvokeVoidAsync("setAllAudioMute", b_is_audio_muted);
    }

    private async void showGame()
    {
        this.game_started = true;
        StateHasChanged();

        await JsRuntime.InvokeVoidAsync("playAudio", "/audio/bgm_test.mp3");
        await JsRuntime.InvokeVoidAsync("setAllAudioMute", b_is_audio_muted);
    }

    /// <summary>
    /// Presents the screen to the user by calling the blitScreen javascript function.
    /// </summary>
    /// <param name="js"></param>
    ///
    public void presentScreen(IJSRuntime js, PixelBuffer frameBuffer)
    {
        IJSUnmarshalledRuntime umjs = (IJSUnmarshalledRuntime)js;
        object result = umjs.InvokeUnmarshalled<byte[], int, int, object>("blitScreen", frameBuffer.pixels, frameBuffer.width, frameBuffer.height);
    }

    [JSInvokable]
    public async ValueTask update(double time_stamp)
    {
        ray_tracer.updateObserver();
        player_hub_conn.SendAsync("updatePlayerPosition", ray_tracer.self.coord);
        map_client.level_map.render();

        foreach(KeyValuePair<Guid, Player> player_conn in connected_players)
        {
            try
            {
                player_conn.Value.render();
            }
            catch (Exception e)
            {
                Console.WriteLine("Exception: {0}", e.ToString());
            }
        }

        presentScreen(JsRuntime, ray_tracer.frameBuffer);
    }

    [JSInvokable]
    public void handleKeyUp(KeyboardEventArgs ke_args)
    {
        string key = ke_args.Key;
        switch (key)
        {
            case "w":
                ray_tracer.input.u = false;
                break;
            case "s":
                ray_tracer.input.d = false;
                break;
            case "a":
                ray_tracer.input.l = false;
                break;
            case "d":
                ray_tracer.input.r = false;
                break;
            default:
                break;
        }
    }

    [JSInvokable]
    public void handleKeyDown(KeyboardEventArgs ke_args)
    {
        string key = ke_args.Key;
        switch (key)
        {
            case "w":
                ray_tracer.input.u = true;
                break;
            case "s":
                ray_tracer.input.d = true;
                break;
            case "a":
                ray_tracer.input.l = true;
                break;
            case "d":
                ray_tracer.input.r = true;
                break;
            default:
                break;
        }
    }

    [JSInvokable]
    public async void handleMouse()
    {
        float x = await JsRuntime.InvokeAsync<float>("pollMouse");
        ray_tracer.input.mouseDelta = x;
    }

    [JSInvokable]
    public async void handlePointerDown(PointerEventArgs pe_args)
    {
        await JsRuntime.InvokeVoidAsync("captureMouse", render_canvas, pe_args.PointerId);
    }
    // Chat Begin

    public async Task sendMsg()
    {
        //await chat_hub_conn.SendAsync("sendMessage", user_input, msg_input);
        await chat_client.sendMsg(msg_input, user_input);
    }

    public void refreshMessages(object sender, ChatMessageEventArgs che_args)
    {
        messages = che_args.Messages;
        StateHasChanged();
    }

    public bool isConnected => chat_hub_conn.State == HubConnectionState.Connected;

    // Chat End

}
