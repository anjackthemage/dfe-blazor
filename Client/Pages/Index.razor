@page "/"

@using Engine;
@using Microsoft.AspNetCore.SignalR.Client;
@using dfe.Client.Engine.Network;
@using dfe.Shared.Entities;
@using dfe.Shared.Render;
@using System.Numerics;
@using System.Collections; 

@inject IJSRuntime JsRuntime;
@inject NavigationManager NavigationManager;


<div id="game_view_container">
    <div>
        <canvas tabindex="0" id="game_canvas" width="640" height="480"
                @ref="render_canvas"
                @onkeydown="handleKeyDown"
                @onkeyup="handleKeyUp"
                @onpointerdown="handlePointerDown"
                @onmousemove="handleMouse">
        </canvas>
    </div>
    <div hidden="@b_is_game_started">
        <div class="centered" style="width: 100%; height: 100%; background-color: gray; opacity: 0.5;">
        </div>
        <div class="centered">
            <button @onclick="showGame">Start Game</button>
        </div>
    </div>
</div>

<div id="chat_container">

    <hr />

    <div>
        <label>
            User:
            <input @bind="user_input" />
        </label>
    </div>
    <div>
        <label>
            Message:
            <input @bind="msg_input" size="50" />
        </label>
    </div>
    <button @onclick="sendMsg" disabled="@(!isConnected)">Send</button>

    <hr />

    <ul>
        @foreach (var message in messages)
        {
            <li>@message</li>
        }
    </ul>
</div>

<div id="audio-elements">
    <input type="checkbox" @onchange="muteClicked" checked /> <label>Mute</label>
    @* For organization purposes, this will contain the audio elements until we have a better audio system in place. *@
</div>

@code {

    // TODO: Need to store a cookie on client machine to save options state (mute, etc,)

    //GameClient game_client = new GameClient();

    protected ElementReference render_canvas;

    private bool b_is_audio_muted = true;

    public bool isConnected;

    // network
    private HubConnection chat_hub_conn;
    private HubConnection map_hub_conn;
    private HubConnection player_hub_conn;

    private Tracer ray_tracer;

    private GameClient game_client;
    //private ChatClient chat_client;
    //private MapClient map_client;
    //private PlayerClient player_client;

    private List<string> messages = new List<string>();
    private string user_input;
    private string msg_input;

    private bool b_is_game_started = false;

    protected override async Task OnInitializedAsync()
    {

        Uri player_hub_uri = NavigationManager.ToAbsoluteUri("/playerhub");
        Uri map_hub_uri = NavigationManager.ToAbsoluteUri("/maphub");
        Uri chat_hub_uri = NavigationManager.ToAbsoluteUri("/chathub");

        game_client = new GameClient(player_hub_uri, map_hub_uri, chat_hub_uri);

        ray_tracer = game_client.ray_tracer;



        // TODO: don't start gameloop until player registration is complete
        // TODO: also, we should probably keep map and chat hidden until we successfully register with server

        //player_client = new PlayerClient(player_hub_conn);

        //map_client = new MapClient(map_hub_conn);
        //map_client.ray_tracer = ray_tracer;
        //map_client.loadMapFromServer();

        //chat_client = new ChatClient(chat_hub_conn);
        //chat_client.onChatUpdated += refreshMessages;

        //await player_hub_conn.SendAsync("registerPlayerConnection", "TestPlayer", ray_tracer.self);

        await base.OnInitializedAsync();
    }

    protected override async Task OnAfterRenderAsync(bool first_render)
    {
        if (first_render)
        {
            await JsRuntime.InvokeAsync<object>("initGame", DotNetObjectReference.Create(this));
        }

    }

    private async void muteClicked(ChangeEventArgs event_args)
    {
        b_is_audio_muted = bool.Parse(event_args.Value.ToString());
        await JsRuntime.InvokeVoidAsync("setAllAudioMute", b_is_audio_muted);
    }

    private async void showGame()
    {
        this.b_is_game_started = true;
        StateHasChanged();

        await JsRuntime.InvokeVoidAsync("playAudio", "/audio/bgm_test.mp3");
        await JsRuntime.InvokeVoidAsync("setAllAudioMute", b_is_audio_muted);
    }

    /// <summary>
    /// Presents the screen to the user by calling the blitScreen javascript function.
    /// </summary>
    /// <param name="js"></param>
    ///
    public void presentScreen(IJSRuntime js, PixelBuffer frameBuffer)
    {
        IJSUnmarshalledRuntime umjs = (IJSUnmarshalledRuntime)js;
        object result = umjs.InvokeUnmarshalled<byte[], int, int, object>("blitScreen", frameBuffer.pixels, frameBuffer.width, frameBuffer.height);
    }

    [JSInvokable]
    public async ValueTask update(double time_stamp)
    {
        //if (PlayerClient.b_is_player_registered)
        //{
        //    ray_tracer.updateObserver();

        //    // TODO: Move these calls to PlayerClient, don't call updateConnectedPlayers every frame.
        //    player_hub_conn.SendAsync("updateConnectedPlayers");
        //    player_hub_conn.SendAsync("updatePlayerPosition", ray_tracer.self.coord);
        //    map_client.level_map.render();

        //    foreach (KeyValuePair<Guid, Player> player_conn in player_client.connected_players)
        //    {
        //        try
        //        {
        //            player_conn.Value.render();
        //        }
        //        catch (Exception e)
        //        {
        //            Console.WriteLine("Exception: {0}", e.ToString());
        //        }
        //    }
        game_client.render();
        presentScreen(JsRuntime, ray_tracer.frameBuffer);
        //}
    }

    [JSInvokable]
    public void handleKeyUp(KeyboardEventArgs ke_args)
    {
        string key = ke_args.Key;
        switch (key)
        {
            case "w":
                ray_tracer.input.u = false;
                break;
            case "s":
                ray_tracer.input.d = false;
                break;
            case "a":
                ray_tracer.input.l = false;
                break;
            case "d":
                ray_tracer.input.r = false;
                break;
            default:
                break;
        }
    }

    [JSInvokable]
    public void handleKeyDown(KeyboardEventArgs ke_args)
    {
        string key = ke_args.Key;
        switch (key)
        {
            case "w":
                ray_tracer.input.u = true;
                break;
            case "s":
                ray_tracer.input.d = true;
                break;
            case "a":
                ray_tracer.input.l = true;
                break;
            case "d":
                ray_tracer.input.r = true;
                break;
            default:
                break;
        }
    }

    [JSInvokable]
    public async void handleMouse()
    {
        float x = await JsRuntime.InvokeAsync<float>("pollMouse");
        ray_tracer.input.mouseDelta = x;
    }

    [JSInvokable]
    public async void handlePointerDown(PointerEventArgs pe_args)
    {
        await JsRuntime.InvokeVoidAsync("captureMouse", render_canvas, pe_args.PointerId);
    }
    // Chat Begin

    public async Task sendMsg()
    {
        //await chat_hub_conn.SendAsync("sendMessage", user_input, msg_input);
        await game_client.chat_client.sendMsg(msg_input, user_input);
    }

    public void refreshMessages(object sender, ChatMessageEventArgs che_args)
    {
        messages = che_args.Messages;
        StateHasChanged();
    }



    // Chat End

}
